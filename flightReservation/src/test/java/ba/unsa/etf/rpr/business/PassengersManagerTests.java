package ba.unsa.etf.rpr.business;

import ba.unsa.etf.rpr.dao.FlightsDaoSQLImpl;
import ba.unsa.etf.rpr.dao.PassengersDaoSQLImpl;
import ba.unsa.etf.rpr.dao.DaoFactory;
import ba.unsa.etf.rpr.domain.Flights;
import ba.unsa.etf.rpr.domain.Passengers;
import ba.unsa.etf.rpr.domain.Passengers;
import ba.unsa.etf.rpr.exceptions.FlightBookingException;
import org.apache.commons.lang3.RandomStringUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import static org.mockito.Mockito.when;
import java.time.LocalDate;

public class PassengersManagerTests {

    private PassengersManager passengersManager;
    /**
     * A Passengers object used in the tests.
     */
    private Passengers passenger;
    /**
     A mocked instance of the PassengersDaoSQLImpl class.
     */
    private PassengersDaoSQLImpl passengersDaoSQLMock;
    /**
     * A list of  Passengers objects used in the tests.
     */
    private List<Passengers> passengers;
    /**
     * This method initializes the objects required for testing.
     */

    @BeforeEach
    public void initializeObjectsWeNeed(){
        passengersManager = Mockito.mock(PassengersManager.class);
        passenger = new Passengers();
        passenger.setName("Stig");
        passenger.setSurname("Stigić");
        passenger.setDateOfBirth(LocalDate.parse("2022-12-22"));
        passenger.setAdress("Silverstone 00");
        passenger.setAdress("stig.stigovic@topgear.uk");

        passenger.setId(1);

        passengersDaoSQLMock = Mockito.mock(PassengersDaoSQLImpl.class);
        passengers = new ArrayList<>();
        passengers.addAll(Arrays.asList( new Passengers("A") ,new Passengers("B"), new Passengers("C"), new Passengers("D"), new Passengers("E") ));
    }
    /**
     * Test for the add() method of PassengersManager class.
     * This test mocks the DaoFactory class to return a mocked PassengersDao object.
     * The add() method of PassengersManager is verified to be called and the expected
     * FlightBookingException is thrown and its message is tested.
     * @throws FlightBookingException if the add() method fails to add a passenger
     */
    @Test
    void add() throws FlightBookingException{
        MockedStatic<DaoFactory> daoFactoryMockedStatic = Mockito.mockStatic(DaoFactory.class);

        daoFactoryMockedStatic.when(DaoFactory::passengersDao).thenReturn(passengersDaoSQLMock);
        when(DaoFactory.passengersDao().getAll()).thenReturn(passengers);
        Mockito.doCallRealMethod().when(passengersManager).add(passenger);


        FlightBookingException flightBookingException = Assertions.assertThrows(FlightBookingException.class, () ->{
            passengersManager.add(passenger);
        },"Can't add passenger with ID. ID is autogenerated");
        Assertions.assertEquals("Can't add passenger with ID. ID is autogenerated",flightBookingException.getMessage());

        Assertions.assertEquals("Can't add passenger with ID. ID is autogenerated",flightBookingException.getMessage());

        daoFactoryMockedStatic.verify(DaoFactory::passengersDao);
        Mockito.verify(passengersManager).add(passenger);
        daoFactoryMockedStatic.close();
    }

    /**
     * This test method tests the add() method of the PassengersManager class.
     * It creates a new instance of the Passengers class with the name "Ceiling",
     * and then calls the add() method of the passengersManager object to add this passenger.
     * The test then uses Assertions.assertTrue() to verify that the passenger was added successfully,
     * and Mockito.verify() to check that the add() method was indeed called.
     * @throws FlightBookingException if an exception occurs while adding the passenger
     */
    @Test
    public void add2()throws FlightBookingException{
        Passengers newPassenger = new Passengers("Ceiling");
        passengersManager.add(newPassenger);

        Assertions.assertTrue(true);
        Mockito.verify(passengersManager).add(newPassenger);
    }

    /**
     This method tests the validatePassengerName() method in PassengersManager.
     It checks if the correct  name is accepted and if the incorrect name throw an exception with the correct message.
     @throws FlightBookingException when the name is incorrect.
     */
    @Test
    void validatePassengerName() throws FlightBookingException{
        String correctName ="Mustafa";
        try {
            Mockito.doCallRealMethod().when(passengersManager).validatePassengerName(correctName);
        }catch(FlightBookingException f){
            f.printStackTrace();
            Assertions.assertTrue(false);
        }

        String incorrectName = "A";
        Mockito.doCallRealMethod().when(passengersManager).validatePassengerName(incorrectName);
        FlightBookingException flightBookingException = Assertions.assertThrows(FlightBookingException.class, () -> {passengersManager.validatePassengerName(incorrectName);},"Passenger name must be between 3 and 20 characters long");
        Assertions.assertEquals("Passenger name must be between 3 and 20 characters long",flightBookingException.getMessage());


    }
    /**
     This method tests the validatePassengerSurname() method in PassengersManager.
     It checks if the correct surname is accepted and if the incorrect surname throw an exception with the correct message.
     @throws FlightBookingException when the surname is incorrect.
     */
    @Test
    void validatePassengerSurname() throws FlightBookingException{
        String correctSurname ="Sudžuka";
        try {
            Mockito.doCallRealMethod().when(passengersManager).validatePassengerSurname(correctSurname);
        }catch(FlightBookingException f){
            f.printStackTrace();
            Assertions.assertTrue(false);
        }

        String incorrectSurname = "A";
        Mockito.doCallRealMethod().when(passengersManager).validatePassengerSurname(incorrectSurname);
        FlightBookingException flightBookingException = Assertions.assertThrows(FlightBookingException.class, () -> {passengersManager.validatePassengerSurname(incorrectSurname);},"Passenger surname must be between 3 and 20 characters long");
        Assertions.assertEquals("Passenger surname must be between 3 and 20 characters long",flightBookingException.getMessage());


    }
    /**
     * The validatePassengerAddress() method is tested in this JUnit test.
     * The correct email address, "mustafa.sudzuka@gmail.com", is passed to the method to ensure that it is accepted.
     * An incorrect email address, "A", is also passed to the method and a FlightBookingException is expected with a message
     * "Passenger address must be between 3 and 20 characters long".
     * The test checks if the exception message matches the expected value.
     */
    @Test
    void validatePassengerAddress() throws FlightBookingException{
        String correctAddress ="mustafa.sudzuka@gmail.com";
        try {
            Mockito.doCallRealMethod().when(passengersManager).validatePassengerAddress(correctAddress);
        }catch(FlightBookingException f){
            f.printStackTrace();
            Assertions.assertTrue(false);
        }

        String incorrectAddress = "A";
        Mockito.doCallRealMethod().when(passengersManager).validatePassengerAddress(incorrectAddress);
        FlightBookingException flightBookingException = Assertions.assertThrows(FlightBookingException.class, () -> {passengersManager.validatePassengerAddress(incorrectAddress);},"Passenger address must be between 3 and 20 characters long");
        Assertions.assertEquals("Passenger address must be between 3 and 20 characters long",flightBookingException.getMessage());


    }
}
